-- -*- haskell -*-
-- This Alex file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns #-}
{-# OPTIONS_GHC -w #-}
module LexM where



import qualified Data.Bits
import Data.Word (Word8)
import Data.Char (ord)
}


$l = [a-zA-Z\192 - \255] # [\215 \247]    -- isolatin1 letter FIXME
$c = [A-Z\192-\221] # [\215]    -- capital isolatin1 letter FIXME
$s = [a-z\222-\255] # [\247]    -- small isolatin1 letter FIXME
$d = [0-9]                -- digit
$i = [$l $d _ ']          -- identifier character
$u = [\0-\255]          -- universal: any character


:-
"%" [.]* ; -- Toss single line comments
"/*" ([$u # \*] | \*+ [$u # [\* \/]])* ("*")+ "/" ;

$white+ ;

\+ { tok (\p s -> PT p (eitherResIdent (T_ADD . share) s)) }
\- { tok (\p s -> PT p (eitherResIdent (T_SUB . share) s)) }
\* { tok (\p s -> PT p (eitherResIdent (T_MUL . share) s)) }
\/ { tok (\p s -> PT p (eitherResIdent (T_DIV . share) s)) }
\= \> { tok (\p s -> PT p (eitherResIdent (T_ARROW . share) s)) }
\& \& { tok (\p s -> PT p (eitherResIdent (T_AND . share) s)) }
\| \| { tok (\p s -> PT p (eitherResIdent (T_OR . share) s)) }
n o t { tok (\p s -> PT p (eitherResIdent (T_NOT . share) s)) }
\= { tok (\p s -> PT p (eitherResIdent (T_EQUAL . share) s)) }
\< { tok (\p s -> PT p (eitherResIdent (T_LT . share) s)) }
\> { tok (\p s -> PT p (eitherResIdent (T_GT . share) s)) }
\= \< { tok (\p s -> PT p (eitherResIdent (T_LE . share) s)) }
\> \= { tok (\p s -> PT p (eitherResIdent (T_GE . share) s)) }
\: \= { tok (\p s -> PT p (eitherResIdent (T_ASSIGN . share) s)) }
\( { tok (\p s -> PT p (eitherResIdent (T_LPAR . share) s)) }
\) { tok (\p s -> PT p (eitherResIdent (T_RPAR . share) s)) }
\{ { tok (\p s -> PT p (eitherResIdent (T_CLPAR . share) s)) }
\} { tok (\p s -> PT p (eitherResIdent (T_CRPAR . share) s)) }
\[ { tok (\p s -> PT p (eitherResIdent (T_SLPAR . share) s)) }
\] { tok (\p s -> PT p (eitherResIdent (T_SRPAR . share) s)) }
\| { tok (\p s -> PT p (eitherResIdent (T_SLASH . share) s)) }
\: { tok (\p s -> PT p (eitherResIdent (T_COLON . share) s)) }
\; { tok (\p s -> PT p (eitherResIdent (T_SEMICOLON . share) s)) }
\, { tok (\p s -> PT p (eitherResIdent (T_COMMA . share) s)) }
i f { tok (\p s -> PT p (eitherResIdent (T_IF . share) s)) }
t h e n { tok (\p s -> PT p (eitherResIdent (T_THEN . share) s)) }
w h i l e { tok (\p s -> PT p (eitherResIdent (T_WHILE . share) s)) }
d o { tok (\p s -> PT p (eitherResIdent (T_DO . share) s)) }
r e a d { tok (\p s -> PT p (eitherResIdent (T_READ . share) s)) }
e l s e { tok (\p s -> PT p (eitherResIdent (T_ELSE . share) s)) }
b e g i n { tok (\p s -> PT p (eitherResIdent (T_BEGIN . share) s)) }
e n d { tok (\p s -> PT p (eitherResIdent (T_END . share) s)) }
c a s e { tok (\p s -> PT p (eitherResIdent (T_CASE . share) s)) }
o f { tok (\p s -> PT p (eitherResIdent (T_OF . share) s)) }
p r i n t { tok (\p s -> PT p (eitherResIdent (T_PRINT . share) s)) }
i n t { tok (\p s -> PT p (eitherResIdent (T_INT . share) s)) }
b o o l { tok (\p s -> PT p (eitherResIdent (T_BOOL . share) s)) }
c h a r { tok (\p s -> PT p (eitherResIdent (T_CHAR . share) s)) }
r e a l { tok (\p s -> PT p (eitherResIdent (T_REAL . share) s)) }
v a r { tok (\p s -> PT p (eitherResIdent (T_VAR . share) s)) }
d a t a { tok (\p s -> PT p (eitherResIdent (T_DATA . share) s)) }
s i z e { tok (\p s -> PT p (eitherResIdent (T_SIZE . share) s)) }
f l o a t { tok (\p s -> PT p (eitherResIdent (T_FLOAT . share) s)) }
f l o o r { tok (\p s -> PT p (eitherResIdent (T_FLOOR . share) s)) }
c e i l { tok (\p s -> PT p (eitherResIdent (T_CEIL . share) s)) }
f u n { tok (\p s -> PT p (eitherResIdent (T_FUN . share) s)) }
r e t u r n { tok (\p s -> PT p (eitherResIdent (T_RETURN . share) s)) }
\# (\_ | $l | $d)* { tok (\p s -> PT p (eitherResIdent (T_CID . share) s)) }
$l (\_ | $l | $d)* { tok (\p s -> PT p (eitherResIdent (T_ID . share) s)) }
$d + { tok (\p s -> PT p (eitherResIdent (T_IVAL . share) s)) }
$d + \. $d + { tok (\p s -> PT p (eitherResIdent (T_RVAL . share) s)) }
t r u e | f a l s e { tok (\p s -> PT p (eitherResIdent (T_BVAL . share) s)) }
\" (\n)\" | \" (\t)\" | \" ($c ($l | $d | \_)) \" { tok (\p s -> PT p (eitherResIdent (T_CVAL . share) s)) }

$l $i*   { tok (\p s -> PT p (eitherResIdent (TV . share) s)) }





{

tok :: (Posn -> String -> Token) -> (Posn -> String -> Token)
tok f p s = f p s

share :: String -> String
share = id

data Tok =
   TS !String !Int    -- reserved words and symbols
 | TL !String         -- string literals
 | TI !String         -- integer literals
 | TV !String         -- identifiers
 | TD !String         -- double precision float literals
 | TC !String         -- character literals
 | T_ADD !String
 | T_SUB !String
 | T_MUL !String
 | T_DIV !String
 | T_ARROW !String
 | T_AND !String
 | T_OR !String
 | T_NOT !String
 | T_EQUAL !String
 | T_LT !String
 | T_GT !String
 | T_LE !String
 | T_GE !String
 | T_ASSIGN !String
 | T_LPAR !String
 | T_RPAR !String
 | T_CLPAR !String
 | T_CRPAR !String
 | T_SLPAR !String
 | T_SRPAR !String
 | T_SLASH !String
 | T_COLON !String
 | T_SEMICOLON !String
 | T_COMMA !String
 | T_IF !String
 | T_THEN !String
 | T_WHILE !String
 | T_DO !String
 | T_READ !String
 | T_ELSE !String
 | T_BEGIN !String
 | T_END !String
 | T_CASE !String
 | T_OF !String
 | T_PRINT !String
 | T_INT !String
 | T_BOOL !String
 | T_CHAR !String
 | T_REAL !String
 | T_VAR !String
 | T_DATA !String
 | T_SIZE !String
 | T_FLOAT !String
 | T_FLOOR !String
 | T_CEIL !String
 | T_FUN !String
 | T_RETURN !String
 | T_CID !String
 | T_ID !String
 | T_IVAL !String
 | T_RVAL !String
 | T_BVAL !String
 | T_CVAL !String

 deriving (Eq,Show,Ord)

data Token =
   PT  Posn Tok
 | Err Posn
  deriving (Eq,Show,Ord)

printPosn :: Posn -> String
printPosn (Pn _ l c) = "line " ++ show l ++ ", column " ++ show c

tokenPos :: [Token] -> String
tokenPos (t:_) = printPosn (tokenPosn t)
tokenPos [] = "end of file"

tokenPosn :: Token -> Posn
tokenPosn (PT p _) = p
tokenPosn (Err p) = p

tokenLineCol :: Token -> (Int, Int)
tokenLineCol = posLineCol . tokenPosn

posLineCol :: Posn -> (Int, Int)
posLineCol (Pn _ l c) = (l,c)

mkPosToken :: Token -> ((Int, Int), String)
mkPosToken t@(PT p _) = (posLineCol p, prToken t)

prToken :: Token -> String
prToken t = case t of
  PT _ (TS s _) -> s
  PT _ (TL s)   -> show s
  PT _ (TI s)   -> s
  PT _ (TV s)   -> s
  PT _ (TD s)   -> s
  PT _ (TC s)   -> s
  Err _         -> "#error"
  PT _ (T_ADD s) -> s
  PT _ (T_SUB s) -> s
  PT _ (T_MUL s) -> s
  PT _ (T_DIV s) -> s
  PT _ (T_ARROW s) -> s
  PT _ (T_AND s) -> s
  PT _ (T_OR s) -> s
  PT _ (T_NOT s) -> s
  PT _ (T_EQUAL s) -> s
  PT _ (T_LT s) -> s
  PT _ (T_GT s) -> s
  PT _ (T_LE s) -> s
  PT _ (T_GE s) -> s
  PT _ (T_ASSIGN s) -> s
  PT _ (T_LPAR s) -> s
  PT _ (T_RPAR s) -> s
  PT _ (T_CLPAR s) -> s
  PT _ (T_CRPAR s) -> s
  PT _ (T_SLPAR s) -> s
  PT _ (T_SRPAR s) -> s
  PT _ (T_SLASH s) -> s
  PT _ (T_COLON s) -> s
  PT _ (T_SEMICOLON s) -> s
  PT _ (T_COMMA s) -> s
  PT _ (T_IF s) -> s
  PT _ (T_THEN s) -> s
  PT _ (T_WHILE s) -> s
  PT _ (T_DO s) -> s
  PT _ (T_READ s) -> s
  PT _ (T_ELSE s) -> s
  PT _ (T_BEGIN s) -> s
  PT _ (T_END s) -> s
  PT _ (T_CASE s) -> s
  PT _ (T_OF s) -> s
  PT _ (T_PRINT s) -> s
  PT _ (T_INT s) -> s
  PT _ (T_BOOL s) -> s
  PT _ (T_CHAR s) -> s
  PT _ (T_REAL s) -> s
  PT _ (T_VAR s) -> s
  PT _ (T_DATA s) -> s
  PT _ (T_SIZE s) -> s
  PT _ (T_FLOAT s) -> s
  PT _ (T_FLOOR s) -> s
  PT _ (T_CEIL s) -> s
  PT _ (T_FUN s) -> s
  PT _ (T_RETURN s) -> s
  PT _ (T_CID s) -> s
  PT _ (T_ID s) -> s
  PT _ (T_IVAL s) -> s
  PT _ (T_RVAL s) -> s
  PT _ (T_BVAL s) -> s
  PT _ (T_CVAL s) -> s


data BTree = N | B String Tok BTree BTree deriving (Show)

eitherResIdent :: (String -> Tok) -> String -> Tok
eitherResIdent tv s = treeFind resWords
  where
  treeFind N = tv s
  treeFind (B a t left right) | s < a  = treeFind left
                              | s > a  = treeFind right
                              | s == a = t

resWords :: BTree
resWords = N
   where b s n = let bs = id s
                  in B bs (TS bs n)

unescapeInitTail :: String -> String
unescapeInitTail = id . unesc . tail . id where
  unesc s = case s of
    '\\':c:cs | elem c ['\"', '\\', '\''] -> c : unesc cs
    '\\':'n':cs  -> '\n' : unesc cs
    '\\':'t':cs  -> '\t' : unesc cs
    '"':[]    -> []
    c:cs      -> c : unesc cs
    _         -> []

-------------------------------------------------------------------
-- Alex wrapper code.
-- A modified "posn" wrapper.
-------------------------------------------------------------------

data Posn = Pn !Int !Int !Int
      deriving (Eq, Show,Ord)

alexStartPos :: Posn
alexStartPos = Pn 0 1 1

alexMove :: Posn -> Char -> Posn
alexMove (Pn a l c) '\t' = Pn (a+1)  l     (((c+7) `div` 8)*8+1)
alexMove (Pn a l c) '\n' = Pn (a+1) (l+1)   1
alexMove (Pn a l c) _    = Pn (a+1)  l     (c+1)

type Byte = Word8

type AlexInput = (Posn,     -- current position,
                  Char,     -- previous char
                  [Byte],   -- pending bytes on the current char
                  String)   -- current input string

tokens :: String -> [Token]
tokens str = go (alexStartPos, '\n', [], str)
    where
      go :: AlexInput -> [Token]
      go inp@(pos, _, _, str) =
               case alexScan inp 0 of
                AlexEOF                   -> []
                AlexError (pos, _, _, _)  -> [Err pos]
                AlexSkip  inp' len        -> go inp'
                AlexToken inp' len act    -> act pos (take len str) : (go inp')

alexGetByte :: AlexInput -> Maybe (Byte,AlexInput)
alexGetByte (p, c, (b:bs), s) = Just (b, (p, c, bs, s))
alexGetByte (p, _, [], s) =
  case  s of
    []  -> Nothing
    (c:s) ->
             let p'     = alexMove p c
                 (b:bs) = utf8Encode c
              in p' `seq` Just (b, (p', c, bs, s))

alexInputPrevChar :: AlexInput -> Char
alexInputPrevChar (p, c, bs, s) = c

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
utf8Encode = map fromIntegral . go . ord
 where
  go oc
   | oc <= 0x7f       = [oc]

   | oc <= 0x7ff      = [ 0xc0 + (oc `Data.Bits.shiftR` 6)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]

   | oc <= 0xffff     = [ 0xe0 + (oc `Data.Bits.shiftR` 12)
                        , 0x80 + ((oc `Data.Bits.shiftR` 6) Data.Bits..&. 0x3f)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]
   | otherwise        = [ 0xf0 + (oc `Data.Bits.shiftR` 18)
                        , 0x80 + ((oc `Data.Bits.shiftR` 12) Data.Bits..&. 0x3f)
                        , 0x80 + ((oc `Data.Bits.shiftR` 6) Data.Bits..&. 0x3f)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]
}
