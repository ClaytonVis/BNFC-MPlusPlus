-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pDeclarations Declarations
%name pDeclaration Declaration
%name pVar_Declaration Var_Declaration
%name pType Type
%name pArray_Dimensions Array_Dimensions
%name pFun_Declaration Fun_Declaration
%name pFun_Block Fun_Block
%name pParam_List Param_List
%name pParameters Parameters
%name pMore_Parameters More_Parameters
%name pBasic_Declaration Basic_Declaration
%name pBasic_Array_Dimensions Basic_Array_Dimensions
%name pProgram_Body Program_Body
%name pFun_Body Fun_Body
%name pProg_Stmts Prog_Stmts
%name pProg_Stmt Prog_Stmt
%name pIdentifier Identifier
%name pExpr Expr
%name pBInt_Term BInt_Term
%name pBInt_Factor BInt_Factor
%name pCompare_Op Compare_Op
%name pInt_Expr Int_Expr
%name pAddop Addop
%name pInt_Term Int_Term
%name pMulop Mulop
%name pInt_Factor Int_Factor
%name pModifier_List Modifier_List
%name pArguments Arguments
%name pMore_Arguments More_Arguments
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=<' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  '[' { PT _ (TS _ 17) }
  ']' { PT _ (TS _ 18) }
  'begin' { PT _ (TS _ 19) }
  'bool' { PT _ (TS _ 20) }
  'ceil' { PT _ (TS _ 21) }
  'do' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'end' { PT _ (TS _ 24) }
  'float' { PT _ (TS _ 25) }
  'floor' { PT _ (TS _ 26) }
  'fun' { PT _ (TS _ 27) }
  'if' { PT _ (TS _ 28) }
  'int' { PT _ (TS _ 29) }
  'not' { PT _ (TS _ 30) }
  'print' { PT _ (TS _ 31) }
  'read' { PT _ (TS _ 32) }
  'real' { PT _ (TS _ 33) }
  'return' { PT _ (TS _ 34) }
  'size' { PT _ (TS _ 35) }
  'then' { PT _ (TS _ 36) }
  'var' { PT _ (TS _ 37) }
  'while' { PT _ (TS _ 38) }
  '{' { PT _ (TS _ 39) }
  '||' { PT _ (TS _ 40) }
  '}' { PT _ (TS _ 41) }

L_ID { PT _ (T_ID $$) }
L_IVAL { PT _ (T_IVAL $$) }
L_RVAL { PT _ (T_RVAL $$) }
L_BVAL { PT _ (T_BVAL $$) }


%%

ID    :: { ID} : L_ID { ID ($1)}
IVAL    :: { IVAL} : L_IVAL { IVAL ($1)}
RVAL    :: { RVAL} : L_RVAL { RVAL ($1)}
BVAL    :: { BVAL} : L_BVAL { BVAL ($1)}

Prog :: { Prog }
Prog : Block { AbsM.ProgBlock $1 }
Block :: { Block }
Block : Declarations Program_Body { AbsM.Block1 $1 $2 }
Declarations :: { Declarations }
Declarations : Declaration ';' Declarations { AbsM.Declarations1 $1 $3 }
             | {- empty -} { AbsM.Declarations2 }
Declaration :: { Declaration }
Declaration : Var_Declaration { AbsM.DeclarationVar_Declaration $1 }
            | Fun_Declaration { AbsM.DeclarationFun_Declaration $1 }
Var_Declaration :: { Var_Declaration }
Var_Declaration : 'var' ID Array_Dimensions ':' Type { AbsM.Var_Declaration1 $2 $3 $5 }
Type :: { Type }
Type : 'int' { AbsM.Type_int }
     | 'real' { AbsM.Type_real }
     | 'bool' { AbsM.Type_bool }
Array_Dimensions :: { Array_Dimensions }
Array_Dimensions : '[' Expr ']' Array_Dimensions { AbsM.Array_Dimensions1 $2 $4 }
                 | {- empty -} { AbsM.Array_Dimensions2 }
Fun_Declaration :: { Fun_Declaration }
Fun_Declaration : 'fun' ID Param_List ':' Type '{' Fun_Block '}' { AbsM.Fun_Declaration1 $2 $3 $5 $7 }
Fun_Block :: { Fun_Block }
Fun_Block : Declarations Fun_Body { AbsM.Fun_Block1 $1 $2 }
Param_List :: { Param_List }
Param_List : '(' Parameters ')' { AbsM.Param_List1 $2 }
Parameters :: { Parameters }
Parameters : Basic_Declaration More_Parameters { AbsM.Parameters1 $1 $2 }
           | {- empty -} { AbsM.Parameters2 }
More_Parameters :: { More_Parameters }
More_Parameters : ',' Basic_Declaration More_Parameters { AbsM.More_Parameters1 $2 $3 }
                | {- empty -} { AbsM.More_Parameters2 }
Basic_Declaration :: { Basic_Declaration }
Basic_Declaration : ID Basic_Array_Dimensions ':' Type { AbsM.Basic_Declaration1 $1 $2 $4 }
Basic_Array_Dimensions :: { Basic_Array_Dimensions }
Basic_Array_Dimensions : '[' ']' Basic_Array_Dimensions { AbsM.Basic_Array_Dimensions1 $3 }
                       | {- empty -} { AbsM.Basic_Array_Dimensions2 }
Program_Body :: { Program_Body }
Program_Body : 'begin' Prog_Stmts 'end' { AbsM.Program_Body1 $2 }
Fun_Body :: { Fun_Body }
Fun_Body : 'begin' Prog_Stmts 'return' Expr ';' 'end' { AbsM.Fun_Body1 $2 $4 }
Prog_Stmts :: { Prog_Stmts }
Prog_Stmts : Prog_Stmt ';' Prog_Stmts { AbsM.Prog_Stmts1 $1 $3 }
           | {- empty -} { AbsM.Prog_Stmts2 }
Prog_Stmt :: { Prog_Stmt }
Prog_Stmt : 'if' Expr 'then' Prog_Stmt 'else' Prog_Stmt { AbsM.Prog_Stmt1 $2 $4 $6 }
          | 'while' Expr 'do' Prog_Stmt { AbsM.Prog_Stmt2 $2 $4 }
          | 'read' Identifier { AbsM.Prog_Stmt3 $2 }
          | Identifier ':=' Expr { AbsM.Prog_Stmt4 $1 $3 }
          | 'print' Expr { AbsM.Prog_Stmt5 $2 }
          | '{' Block '}' { AbsM.Prog_Stmt6 $2 }
Identifier :: { Identifier }
Identifier : ID Array_Dimensions { AbsM.Identifier1 $1 $2 }
Expr :: { Expr }
Expr : Expr '||' BInt_Term { AbsM.Expr1 $1 $3 }
     | BInt_Term { AbsM.ExprBInt_Term $1 }
BInt_Term :: { BInt_Term }
BInt_Term : BInt_Term '&&' BInt_Factor { AbsM.BInt_Term1 $1 $3 }
          | BInt_Factor { AbsM.BInt_TermBInt_Factor $1 }
BInt_Factor :: { BInt_Factor }
BInt_Factor : 'not' BInt_Factor { AbsM.BInt_Factor1 $2 }
            | Int_Expr Compare_Op Int_Expr { AbsM.BInt_Factor2 $1 $2 $3 }
            | Int_Expr { AbsM.BInt_FactorInt_Expr $1 }
Compare_Op :: { Compare_Op }
Compare_Op : '=' { AbsM.Compare_Op1 }
           | '<' { AbsM.Compare_Op2 }
           | '>' { AbsM.Compare_Op3 }
           | '=<' { AbsM.Compare_Op4 }
           | '>=' { AbsM.Compare_Op5 }
Int_Expr :: { Int_Expr }
Int_Expr : Int_Expr Addop Int_Term { AbsM.Int_Expr1 $1 $2 $3 }
         | Int_Term { AbsM.Int_ExprInt_Term $1 }
Addop :: { Addop }
Addop : '+' { AbsM.Addop1 } | '-' { AbsM.Addop2 }
Int_Term :: { Int_Term }
Int_Term : Int_Term Mulop Int_Factor { AbsM.Int_Term1 $1 $2 $3 }
         | Int_Factor { AbsM.Int_TermInt_Factor $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsM.Mulop1 } | '/' { AbsM.Mulop2 }
Int_Factor :: { Int_Factor }
Int_Factor : '(' Expr ')' { AbsM.Int_Factor1 $2 }
           | 'size' '(' ID Basic_Array_Dimensions ')' { AbsM.Int_Factor2 $3 $4 }
           | 'float' '(' Expr ')' { AbsM.Int_Factor3 $3 }
           | 'floor' '(' Expr ')' { AbsM.Int_Factor4 $3 }
           | 'ceil' '(' Expr ')' { AbsM.Int_Factor5 $3 }
           | ID Modifier_List { AbsM.Int_Factor6 $1 $2 }
           | IVAL { AbsM.Int_FactorIVAL $1 }
           | RVAL { AbsM.Int_FactorRVAL $1 }
           | BVAL { AbsM.Int_FactorBVAL $1 }
           | '-' Int_Factor { AbsM.Int_Factor7 $2 }
Modifier_List :: { Modifier_List }
Modifier_List : '(' Arguments ')' { AbsM.Modifier_List1 $2 }
              | Array_Dimensions { AbsM.Modifier_ListArray_Dimensions $1 }
Arguments :: { Arguments }
Arguments : Expr More_Arguments { AbsM.Arguments1 $1 $2 }
          | {- empty -} { AbsM.Arguments2 }
More_Arguments :: { More_Arguments }
More_Arguments : ',' Expr More_Arguments { AbsM.More_Arguments1 $2 $3 }
               | {- empty -} { AbsM.More_Arguments2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

