-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProgram Program
%name pBlock Block
%name pDeclarations Declarations
%name pDeclaration Declaration
%name pVar_Declaration Var_Declaration
%name pVar_Specs Var_Specs
%name pMore_Var_Specs More_Var_Specs
%name pVar_Spec Var_Spec
%name pArray_Dimensions Array_Dimensions
%name pType Type
%name pFun_Declaration Fun_Declaration
%name pFun_Block Fun_Block
%name pParam_List Param_List
%name pParameters Parameters
%name pMore_Parameters More_Parameters
%name pBasic_Declaration Basic_Declaration
%name pBasic_Array_Dimensions Basic_Array_Dimensions
%name pData_Declaration Data_Declaration
%name pCons_Declarations Cons_Declarations
%name pMore_Cons_Decl More_Cons_Decl
%name pCons_Decl Cons_Decl
%name pType_List Type_List
%name pMore_Type More_Type
%name pProgram_Body Program_Body
%name pFun_Body Fun_Body
%name pProg_Stmts Prog_Stmts
%name pProg_Stmt Prog_Stmt
%name pLocation Location
%name pCase_List Case_List
%name pMore_Case More_Case
%name pCase Case
%name pVar_List Var_List
%name pVar_List' Var_List'
%name pMore_Var_List' More_Var_List'
%name pExpr Expr
%name pBInt_Term BInt_Term
%name pBInt_Factor BInt_Factor
%name pCompare_Op Compare_Op
%name pInt_Expr Int_Expr
%name pAddop Addop
%name pInt_Term Int_Term
%name pMulop Mulop
%name pInt_Factor Int_Factor
%name pModifier_List Modifier_List
%name pFun_Argument_List Fun_Argument_List
%name pCons_Argument_List Cons_Argument_List
%name pArguments Arguments
%name pMore_Arguments More_Arguments
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token

L_ADD { PT _ (T_ADD $$) }
L_SUB { PT _ (T_SUB $$) }
L_MUL { PT _ (T_MUL $$) }
L_DIV { PT _ (T_DIV $$) }
L_ARROW { PT _ (T_ARROW $$) }
L_AND { PT _ (T_AND $$) }
L_OR { PT _ (T_OR $$) }
L_NOT { PT _ (T_NOT $$) }
L_EQUAL { PT _ (T_EQUAL $$) }
L_LT { PT _ (T_LT $$) }
L_GT { PT _ (T_GT $$) }
L_LE { PT _ (T_LE $$) }
L_GE { PT _ (T_GE $$) }
L_ASSIGN { PT _ (T_ASSIGN $$) }
L_LPAR { PT _ (T_LPAR $$) }
L_RPAR { PT _ (T_RPAR $$) }
L_CLPAR { PT _ (T_CLPAR $$) }
L_CRPAR { PT _ (T_CRPAR $$) }
L_SLPAR { PT _ (T_SLPAR $$) }
L_SRPAR { PT _ (T_SRPAR $$) }
L_SLASH { PT _ (T_SLASH $$) }
L_COLON { PT _ (T_COLON $$) }
L_SEMICOLON { PT _ (T_SEMICOLON $$) }
L_COMMA { PT _ (T_COMMA $$) }
L_IF { PT _ (T_IF $$) }
L_THEN { PT _ (T_THEN $$) }
L_WHILE { PT _ (T_WHILE $$) }
L_DO { PT _ (T_DO $$) }
L_READ { PT _ (T_READ $$) }
L_ELSE { PT _ (T_ELSE $$) }
L_BEGIN { PT _ (T_BEGIN $$) }
L_END { PT _ (T_END $$) }
L_CASE { PT _ (T_CASE $$) }
L_OF { PT _ (T_OF $$) }
L_PRINT { PT _ (T_PRINT $$) }
L_INT { PT _ (T_INT $$) }
L_BOOL { PT _ (T_BOOL $$) }
L_CHAR { PT _ (T_CHAR $$) }
L_REAL { PT _ (T_REAL $$) }
L_VAR { PT _ (T_VAR $$) }
L_DATA { PT _ (T_DATA $$) }
L_SIZE { PT _ (T_SIZE $$) }
L_FLOAT { PT _ (T_FLOAT $$) }
L_FLOOR { PT _ (T_FLOOR $$) }
L_CEIL { PT _ (T_CEIL $$) }
L_FUN { PT _ (T_FUN $$) }
L_RETURN { PT _ (T_RETURN $$) }
L_CID { PT _ (T_CID $$) }
L_ID { PT _ (T_ID $$) }
L_IVAL { PT _ (T_IVAL $$) }
L_RVAL { PT _ (T_RVAL $$) }
L_BVAL { PT _ (T_BVAL $$) }
L_CVAL { PT _ (T_CVAL $$) }


%%

ADD    :: { ADD} : L_ADD { ADD ($1)}
SUB    :: { SUB} : L_SUB { SUB ($1)}
MUL    :: { MUL} : L_MUL { MUL ($1)}
DIV    :: { DIV} : L_DIV { DIV ($1)}
ARROW    :: { ARROW} : L_ARROW { ARROW ($1)}
AND    :: { AND} : L_AND { AND ($1)}
OR    :: { OR} : L_OR { OR ($1)}
NOT    :: { NOT} : L_NOT { NOT ($1)}
EQUAL    :: { EQUAL} : L_EQUAL { EQUAL ($1)}
LT    :: { LT} : L_LT { LT ($1)}
GT    :: { GT} : L_GT { GT ($1)}
LE    :: { LE} : L_LE { LE ($1)}
GE    :: { GE} : L_GE { GE ($1)}
ASSIGN    :: { ASSIGN} : L_ASSIGN { ASSIGN ($1)}
LPAR    :: { LPAR} : L_LPAR { LPAR ($1)}
RPAR    :: { RPAR} : L_RPAR { RPAR ($1)}
CLPAR    :: { CLPAR} : L_CLPAR { CLPAR ($1)}
CRPAR    :: { CRPAR} : L_CRPAR { CRPAR ($1)}
SLPAR    :: { SLPAR} : L_SLPAR { SLPAR ($1)}
SRPAR    :: { SRPAR} : L_SRPAR { SRPAR ($1)}
SLASH    :: { SLASH} : L_SLASH { SLASH ($1)}
COLON    :: { COLON} : L_COLON { COLON ($1)}
SEMICOLON    :: { SEMICOLON} : L_SEMICOLON { SEMICOLON ($1)}
COMMA    :: { COMMA} : L_COMMA { COMMA ($1)}
IF    :: { IF} : L_IF { IF ($1)}
THEN    :: { THEN} : L_THEN { THEN ($1)}
WHILE    :: { WHILE} : L_WHILE { WHILE ($1)}
DO    :: { DO} : L_DO { DO ($1)}
READ    :: { READ} : L_READ { READ ($1)}
ELSE    :: { ELSE} : L_ELSE { ELSE ($1)}
BEGIN    :: { BEGIN} : L_BEGIN { BEGIN ($1)}
END    :: { END} : L_END { END ($1)}
CASE    :: { CASE} : L_CASE { CASE ($1)}
OF    :: { OF} : L_OF { OF ($1)}
PRINT    :: { PRINT} : L_PRINT { PRINT ($1)}
INT    :: { INT} : L_INT { INT ($1)}
BOOL    :: { BOOL} : L_BOOL { BOOL ($1)}
CHAR    :: { CHAR} : L_CHAR { CHAR ($1)}
REAL    :: { REAL} : L_REAL { REAL ($1)}
VAR    :: { VAR} : L_VAR { VAR ($1)}
DATA    :: { DATA} : L_DATA { DATA ($1)}
SIZE    :: { SIZE} : L_SIZE { SIZE ($1)}
FLOAT    :: { FLOAT} : L_FLOAT { FLOAT ($1)}
FLOOR    :: { FLOOR} : L_FLOOR { FLOOR ($1)}
CEIL    :: { CEIL} : L_CEIL { CEIL ($1)}
FUN    :: { FUN} : L_FUN { FUN ($1)}
RETURN    :: { RETURN} : L_RETURN { RETURN ($1)}
CID    :: { CID} : L_CID { CID ($1)}
ID    :: { ID} : L_ID { ID ($1)}
IVAL    :: { IVAL} : L_IVAL { IVAL ($1)}
RVAL    :: { RVAL} : L_RVAL { RVAL ($1)}
BVAL    :: { BVAL} : L_BVAL { BVAL ($1)}
CVAL    :: { CVAL} : L_CVAL { CVAL ($1)}

Program :: { Program }
Program : Block { AbsM.P1 $1 }
Block :: { Block }
Block : Declarations Program_Body { AbsM.P2 $1 $2 }
Declarations :: { Declarations }
Declarations : Declaration SEMICOLON Declarations { AbsM.P3 $1 $2 $3 }
             | {- empty -} { AbsM.P4 }
Declaration :: { Declaration }
Declaration : Var_Declaration { AbsM.P5 $1 }
            | Fun_Declaration { AbsM.P6 $1 }
            | Data_Declaration { AbsM.P7 $1 }
Var_Declaration :: { Var_Declaration }
Var_Declaration : VAR Var_Specs COLON Type { AbsM.P8 $1 $2 $3 $4 }
Var_Specs :: { Var_Specs }
Var_Specs : Var_Spec More_Var_Specs { AbsM.P9 $1 $2 }
More_Var_Specs :: { More_Var_Specs }
More_Var_Specs : COMMA Var_Spec More_Var_Specs { AbsM.P10 $1 $2 $3 }
               | {- empty -} { AbsM.P11 }
Var_Spec :: { Var_Spec }
Var_Spec : ID Array_Dimensions { AbsM.P12 $1 $2 }
Array_Dimensions :: { Array_Dimensions }
Array_Dimensions : SLPAR Expr SRPAR Array_Dimensions { AbsM.P13 $1 $2 $3 $4 }
                 | {- empty -} { AbsM.P14 }
Type :: { Type }
Type : INT { AbsM.P15 $1 }
     | REAL { AbsM.P16 $1 }
     | BOOL { AbsM.P17 $1 }
     | CHAR { AbsM.P18 $1 }
     | ID { AbsM.P19 $1 }
Fun_Declaration :: { Fun_Declaration }
Fun_Declaration : FUN ID Param_List COLON Type CLPAR Fun_Block CRPAR { AbsM.P20 $1 $2 $3 $4 $5 $6 $7 $8 }
Fun_Block :: { Fun_Block }
Fun_Block : Declarations Fun_Body { AbsM.P21 $1 $2 }
Param_List :: { Param_List }
Param_List : LPAR Parameters RPAR { AbsM.P22 $1 $2 $3 }
Parameters :: { Parameters }
Parameters : Basic_Declaration More_Parameters { AbsM.P23 $1 $2 }
           | {- empty -} { AbsM.P24 }
More_Parameters :: { More_Parameters }
More_Parameters : COMMA Basic_Declaration More_Parameters { AbsM.P25 $1 $2 $3 }
                | {- empty -} { AbsM.P26 }
Basic_Declaration :: { Basic_Declaration }
Basic_Declaration : ID Basic_Array_Dimensions COLON Type { AbsM.P27 $1 $2 $3 $4 }
Basic_Array_Dimensions :: { Basic_Array_Dimensions }
Basic_Array_Dimensions : SLPAR SRPAR Basic_Array_Dimensions { AbsM.P28 $1 $2 $3 }
                       | {- empty -} { AbsM.P29 }
Data_Declaration :: { Data_Declaration }
Data_Declaration : DATA ID EQUAL Cons_Declarations { AbsM.P30 $1 $2 $3 $4 }
Cons_Declarations :: { Cons_Declarations }
Cons_Declarations : Cons_Decl More_Cons_Decl { AbsM.P31 $1 $2 }
More_Cons_Decl :: { More_Cons_Decl }
More_Cons_Decl : SLASH Cons_Decl More_Cons_Decl { AbsM.P32 $1 $2 $3 }
               | {- empty -} { AbsM.P33 }
Cons_Decl :: { Cons_Decl }
Cons_Decl : CID OF Type_List { AbsM.P34 $1 $2 $3 }
          | CID { AbsM.P35 $1 }
Type_List :: { Type_List }
Type_List : Type More_Type { AbsM.P36 $1 $2 }
More_Type :: { More_Type }
More_Type : MUL Type More_Type { AbsM.P37 $1 $2 $3 }
          | {- empty -} { AbsM.P38 }
Program_Body :: { Program_Body }
Program_Body : BEGIN Prog_Stmts END { AbsM.P39 $1 $2 $3 }
             | Prog_Stmts { AbsM.P40 $1 }
Fun_Body :: { Fun_Body }
Fun_Body : BEGIN Prog_Stmts RETURN Expr SEMICOLON END { AbsM.P41 $1 $2 $3 $4 $5 $6 }
         | Prog_Stmts RETURN Expr SEMICOLON { AbsM.P42 $1 $2 $3 $4 }
Prog_Stmts :: { Prog_Stmts }
Prog_Stmts : Prog_Stmt SEMICOLON Prog_Stmts { AbsM.P43 $1 $2 $3 }
           | {- empty -} { AbsM.P44 }
Prog_Stmt :: { Prog_Stmt }
Prog_Stmt : IF Expr THEN Prog_Stmt ELSE Prog_Stmt { AbsM.P45 $1 $2 $3 $4 $5 $6 }
          | WHILE Expr DO Prog_Stmt { AbsM.P46 $1 $2 $3 $4 }
          | READ Location { AbsM.P47 $1 $2 }
          | Location ASSIGN Expr { AbsM.P48 $1 $2 $3 }
          | PRINT Expr { AbsM.P49 $1 $2 }
          | CLPAR Block CRPAR { AbsM.P50 $1 $2 $3 }
          | CASE Expr OF CLPAR Case_List CRPAR { AbsM.P51 $1 $2 $3 $4 $5 $6 }
Location :: { Location }
Location : ID Array_Dimensions { AbsM.P52 $1 $2 }
Case_List :: { Case_List }
Case_List : Case More_Case { AbsM.P53 $1 $2 }
More_Case :: { More_Case }
More_Case : SLASH Case More_Case { AbsM.P54 $1 $2 $3 }
          | {- empty -} { AbsM.P55 }
Case :: { Case }
Case : CID Var_List ARROW Prog_Stmt { AbsM.P56 $1 $2 $3 $4 }
Var_List :: { Var_List }
Var_List : LPAR Var_List' RPAR { AbsM.P57 $1 $2 $3 }
         | {- empty -} { AbsM.P58 }
Var_List' :: { Var_List' }
Var_List' : ID More_Var_List' { AbsM.P59 $1 $2 }
More_Var_List' :: { More_Var_List' }
More_Var_List' : COMMA ID More_Var_List' { AbsM.P60 $1 $2 $3 }
               | {- empty -} { AbsM.P61 }
Expr :: { Expr }
Expr : Expr OR BInt_Term { AbsM.P62 $1 $2 $3 }
     | BInt_Term { AbsM.P63 $1 }
BInt_Term :: { BInt_Term }
BInt_Term : BInt_Term AND BInt_Factor { AbsM.P64 $1 $2 $3 }
          | BInt_Factor { AbsM.P65 $1 }
BInt_Factor :: { BInt_Factor }
BInt_Factor : NOT BInt_Factor { AbsM.P66 $1 $2 }
            | Int_Expr Compare_Op Int_Expr { AbsM.P67 $1 $2 $3 }
            | Int_Expr { AbsM.P68 $1 }
Compare_Op :: { Compare_Op }
Compare_Op : EQUAL { AbsM.P69 $1 }
           | LT { AbsM.P70 $1 }
           | GT { AbsM.P71 $1 }
           | LE { AbsM.P72 $1 }
           | GT { AbsM.P73 $1 }
Int_Expr :: { Int_Expr }
Int_Expr : Int_Expr Addop Int_Term { AbsM.P74 $1 $2 $3 }
         | Int_Term { AbsM.P75 $1 }
Addop :: { Addop }
Addop : ADD { AbsM.P76 $1 } | SUB { AbsM.P77 $1 }
Int_Term :: { Int_Term }
Int_Term : Int_Term Mulop Int_Factor { AbsM.P78 $1 $2 $3 }
         | Int_Factor { AbsM.P79 $1 }
Mulop :: { Mulop }
Mulop : MUL { AbsM.P80 $1 } | DIV { AbsM.P81 $1 }
Int_Factor :: { Int_Factor }
Int_Factor : LPAR Expr RPAR { AbsM.P82 $1 $2 $3 }
           | SIZE LPAR ID Basic_Array_Dimensions RPAR { AbsM.P83 $1 $2 $3 $4 $5 }
           | FLOAT LPAR Expr RPAR { AbsM.P84 $1 $2 $3 $4 }
           | FLOOR LPAR Expr RPAR { AbsM.P85 $1 $2 $3 $4 }
           | CEIL LPAR Expr RPAR { AbsM.P86 $1 $2 $3 $4 }
           | ID Modifier_List { AbsM.P87 $1 $2 }
           | CID Cons_Argument_List { AbsM.P88 $1 $2 }
           | IVAL { AbsM.P89 $1 }
           | RVAL { AbsM.P90 $1 }
           | BVAL { AbsM.P91 $1 }
           | CVAL { AbsM.P92 $1 }
           | SUB Int_Factor { AbsM.P93 $1 $2 }
Modifier_List :: { Modifier_List }
Modifier_List : Fun_Argument_List { AbsM.P94 $1 }
              | Array_Dimensions { AbsM.P95 $1 }
Fun_Argument_List :: { Fun_Argument_List }
Fun_Argument_List : LPAR Arguments RPAR { AbsM.P96 $1 $2 $3 }
Cons_Argument_List :: { Cons_Argument_List }
Cons_Argument_List : Fun_Argument_List { AbsM.P97 $1 }
                   | {- empty -} { AbsM.P98 }
Arguments :: { Arguments }
Arguments : Expr More_Arguments { AbsM.P99 $1 $2 }
          | {- empty -} { AbsM.P100 }
More_Arguments :: { More_Arguments }
More_Arguments : COMMA Expr More_Arguments { AbsM.P101 $1 $2 $3 }
               | {- empty -} { AbsM.P102 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

